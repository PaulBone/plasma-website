---
layout: default
title: About Plasma
---
<!--
Copyright (C) 2016 Paul Bone
Licensed as CC BY-NC-ND 4.0
-->

<h1>About</h1>

<p>
We believe that strong static typed, pure functional programming (FP) has a lot
to offer in terms of software reliability and performance.
However it has a well-deserved reputation for being difficult to learn for
newcomers.
FP can also be difficult to use for experienced functional programmers.
</p>

<p>
Multicore computing is ubiquitous and other promising parallel architectures are either available or on the
horizon;
we believe that it is necessary that parallel and concurrent programming is
available and straightforward.
</p>

<h2>Goals</h2>

<p>
Plasma hopes to address these challenges with the following goals.
</p>

<ol>
  <li id="goal-imperative-declarative">
    <p>
      To combine <span class="hl">declarative/functional</span> and
      <span class="hl">imperative</span> programming features.
    </p>

    <p>
      We will combine the safety and reasoning power of strongly typed pure
      FP with a familiar imperative-like syntax.
      We will support
      loops, arrays and other imperative programming features.
      This benefits both experienced developers and novices.
    </p>
  </li>
  <li id="goal-simplicity">
    <p>Simplicity</p>

    <p>
      Keeping things simple is an excellent engineering practice.
      It also makes the language and tools easier to understand.
    </p>

    <p>
      Plasma will have a reduced emphasis and dependence on abstract
      concepts like monads.
      They're still supported, but now they can be <span class="hl">learnt
      gradually</span>.
      Many <a href="docs/plasma_ref.html#interfaces">interfaces</a>
      will have more sensible names, eg:
      <code>Mappable</code> rather than <code>Functor</code>.
      We will also aim for good tooling and a
      consistent syntax;
      things that <span class="hl">are</span> different will
      <span class="hl">look</span> different.
    </p>
  </li>

  <li id="goal-conc-and-par">
    <p>Excellent <span class="hl">parallelism</span> and
      <span class="hl">concurrency</span> support.</p>

    <p>
      Channels, mvars, semaphores, streams, futures and software
      transactional memory provide safer abstractions than traditional
      threads and locks concurrency.
    </p>

    <p>
      <span class="hl">Deterministic parallelism</span>
      makes parallelism available without constraining the structure of
      your program or affecting its side-effect free semantics,
      eg: Haskell's <code>par</code> function or
      <span class="hldef">strategies</span>.
    </p>

    <p>
      <span class="hl">Automatic parallelism</span> can optimize your code
      by applying deterministic parallelism for you during compilation.
    </p>
  </li>
</ol>

<p>
For more information and an overview of some features
please see the
<a href="#talk_2016">Presentation at Compose :: Melbourne 2016</a>.

<h2>Features</h2>

<dl>
<dt>Side-effect free and single-assignment</dt>
<dd>helping programmers more confidently understand their
programs, making debugging easier.
Side-effect free semantics also make it easier to apply many optimisations
including automatic parallelisation.
Plasma uses a <i>resource</i> system to make effects safe.
Resources are composable unlike monads.
</dd>
<dt>A strong, static type system</dt>
<dd>supporting ADTs, parametric polymorphism,
  <a href="docs/plasma_ref.html#interfaces">interfaces</a>
  and type inference.</dd>
<dt>Eagerly evaluated.</dt>
<dd>Eager evaluation makes performance and other behaviours more
predictable.</dd>
<dt>Direct support for loops</dt>
<dd>for map, reduce, filter and combinations.
Loops work on different aggregate types.
See <a href="docs/plasma_ref.html#loops">Loops in the reference manual</a>.
</dd>
<dt>Bytecode and native code</dt>
<dd>Generic token-based bytecode interpreter,
in the future more optimal bytecode interpreters for each major platform.
and hopefully native code generation.
<dt>Foreign Function Interface (FFI)</dt>
<dd>Interoperability with C.
<dt>Multiple concurrency abstractions</dt>
<dd>Tasks, channels, mvars, futures and STM.
<dt>Manual and automatic parallelisation</dt>
<dd>Parallelise programs based on data-flow, loops and possibly pipelines
either by adding annotations or automatically.
See my
<a href="https://paul.bone.id.au/pub/pbone-2012-thesis/">Ph.D. research</a>.
</dd>
<dt>Free/Libre software</dt>
<dd>MIT License</dd>
</dl>

<h2 id="Publications">Publications</h2>

<p>
The following things have been published about Plasma.
</p>

<ul class="bibliography">
  <li id="talk_2017">
	<span class="author">P. Bone</span>
	<span class="title">Plasma Programming Language</span>
	<span class="conf">Linux Users of Victoria</span>
	<span class="when">May, 2017</span>
	<span class="links">
	  <a href="pub/pbone-2017-plasma.pdf" target-"_blank">Slides</a>
	</span>
  </li>

  <li id="talk_2016">
	<span class="author">P. Bone</span>
	<span class="title">Plasma Programming Language</span>
	<span class="conf">Compose :: Melbourne Conference</span>
	<span class="when">Aug, 2016</span>
	<span class="links">
	  <a href="pub/pbone-2016-plasma.pdf" target-"_blank">Slides</a>
	  [Video below]
	</span>
  </li>
</ul>

<iframe width="560" height="315"
	 src="https://www.youtube.com/embed/sIVzfYelaS4"
	 frameborder="0" allowfullscreen></iframe>

