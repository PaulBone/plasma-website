---
layout: post
author: Paul Bone
title: Programming Language Checklist
excerpt: It's traditional to evaluate any new language using this (in)famous checklist.  Let's try it for Plasma.
---

<p>
It's traditional to evaluate any new language using this (in)famous
checklist (it's a joke, but good humor reflects reality).
It's almost Plasma's 5th birthday so let's call this an early birthday
present and mark the occasion by filling in the checklist.
I've answered with:
</p>

<ul>
  <li><tt>X</tt> - Check!</li>
  <li><tt>W</tt> - Work-in-progress/planned/intended.
    These would be an "X" if we were pushing people to use Plasma as it is
    today.</li>
  <li><tt>Y</tt> - Plasma has this feature.</li>
  <li><tt>N</tt> - Plasma does not have this feature, and it is not
    planned.</li>
  <li><tt>?</tt> - Unsure if we should have this feature.</li>
</ul>

<p>
There are also footnotes at the bottom.
</p>

<p>
Programming Language Checklist<br>
Downloaded from
<a
  href="https://www.famicol.in/language_checklist.html">www.famicol.in/language_checklist.html</a>.
Written by <a href="https://famicol.in">Colin McMillen</a>, <a href="http://jcreed.org">Jason Reed</a>, and <a href="https://elly.town/">Elly Fong-Jones</a>, 2011-10-10.
</p>

<tt>
<pre>
You appear to be advocating a new:
[X] functional  [ ] imperative  [ ] object-oriented  [X] procedural [ ] stack-based
[ ] "multi-paradigm"  [ ] lazy  [X] eager  [X] statically-typed  [ ] dynamically-typed
[X] pure  [ ] impure  [ ] non-hygienic  [ ] visual  [X] beginner-friendly
[ ] non-programmer-friendly  [ ] completely incomprehensible
programming language.  Your language will not work.  Here is why it will not work.

You appear to believe that:
[ ] Syntax is what makes programming difficult
[X] Garbage collection is free                [ ] Computers have infinite memory
[ ] Nobody really needs:
    [W] concurrency  [W] a REPL  [W] debugger support  [ ] IDE support  [ ] I/O
    [W] to interact with code not written in your language
[W] The entire world speaks 7-bit ASCII
[X] Scaling up to large software projects will be easy
[X] Convincing programmers to adopt a new language will be easy
[ ] Convincing programmers to adopt a language-specific IDE will be easy
[ ] Programmers love writing lots of boilerplate
[ ] Specifying behaviors as "undefined" means that programmers won't rely on them
[ ] "Spooky action at a distance" makes programming more fun

Unfortunately, your language (has/lacks):
[Y] comprehensible syntax  [N] semicolons  [N] significant whitespace  [N] macros
[N] implicit type conversion  [N] explicit casting  [Y] type inference
[N] goto  [W] exceptions  [Y] closures  [Y] tail recursion  [W] coroutines
[N] reflection  [W] subtyping  [N] multiple inheritance  [N] operator overloading
[Y] algebraic datatypes  [Y] recursive types  [Y] polymorphic types
[1] covariant array typing  [W] monads  [N] dependent types
[Y] infix operators  [N] nested comments  [?] multi-line strings  [N] regexes
[Y] call-by-value  [N] call-by-name  [N] call-by-reference  [N] call-cc

The following philosophical objections apply:
[ ] Programmers should not need to understand category theory to write "Hello, World!"
[ ] Programmers should not develop RSI from writing "Hello, World!"
[W] The most significant program written in your language is its own compiler
[X] The most significant program written in your language isn't even its own compiler
[X] No language spec
[ ] "The implementation is the spec"
   [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you
[ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed
   [ ] a proof of same is attached
   [ ] invoking this proof crashes the compiler
[X] The name of your language makes it impossible to find on Google
[ ] Interpreted languages will never be as fast as C
[ ] Compiled languages will never be "extensible"
[ ] Writing a compiler that understands English is AI-complete
[X] Your language relies on an optimization which has never been shown possible
[ ] There are less than 100 programmers on Earth smart enough to use your language
[ ] ____________________________ takes exponential time
[2] Alias analysis______________ is known to be undecidable / incomplete (write-in)

Your implementation has the following flaws:
[ ] CPUs do not work that way
[ ] RAM does not work that way
[ ] VMs do not work that way
[ ] Compilers do not work that way
[ ] Compilers cannot work that way
[ ] Shift-reduce conflicts in parsing seem to be resolved using rand()
[ ] You require the compiler to be present at runtime
[ ] You require the language runtime to be present at compile-time
[W] Your compiler errors are completely inscrutable
[ ] Dangerous behavior is only a warning
[W] The compiler crashes if you look at it funny
[ ] The VM crashes if you look at it funny
[ ] You don't seem to understand basic optimization techniques
[ ] You don't seem to understand basic systems programming
[ ] You don't seem to understand pointers
[ ] You don't seem to understand functions

Additionally, your marketing has the following problems:
[ ] Unsupported claims of increased productivity
[X] Unsupported claims of greater "ease of use"
[ ] Obviously rigged benchmarks
   [ ] Graphics, simulation, or crypto benchmarks where your code just calls
       handwritten assembly through your FFI
   [ ] String-processing benchmarks where you just call PCRE
   [ ] Matrix-math benchmarks where you just call BLAS
[3] Noone really believes that your language is faster than:
    [W] assembly  [W] C  [W] FORTRAN  [W] Java  [ ] Ruby  [ ] Prolog
[ ] Rejection of orthodox programming-language theory without justification
[ ] Rejection of orthodox systems programming without justification
[ ] Rejection of orthodox algorithmic theory without justification
[ ] Rejection of basic computer science without justification

Taking the wider ecosystem into account, I would like to note that:
[X] Your complex sample code would be one line in: Haskell/APL/J/K/Perl
[ ] We already have an unsafe imperative language
[ ] We already have a safe imperative OO language
[X] We already have a safe statically-typed eager functional language
    (Paul notes that OCaml is impure)
[ ] You have reinvented Lisp but worse
[ ] You have reinvented Javascript but worse
[ ] You have reinvented Java but worse
[ ] You have reinvented C++ but worse
[ ] You have reinvented PHP but worse
[ ] You have reinvented PHP better, but that's still no justification
[ ] You have reinvented Brainfuck but non-ironically

In conclusion, this is what I think of you:
[X] You have some interesting ideas, but this won't fly.
[ ] This is a bad language, and you should feel bad for inventing it.
[ ] Programming in this language is an adequate punishment for inventing it.
</pre>
</tt>

<br>
Footnotes:
<br>
<ul>
  <li>1. I don't remember which is which, covariant or contravariant.  We
    probably need each of them in each circumstance.  Hopefully I get it
    right.</li>
  <li>2. Uniqueness analysis will be necessary for some features but will
    always be an approximation.
    On edge cases this will either lead to unsatisfactory performance or
    arguments between the programmer and the compiler.</li>
  <li>3. Depends what you mean by "faster than".  Multicore Plasma may well
    be faster than single-core assembler.  It is likely to be faster when
    you also consider the ease of writing parallel code in Plasma.
    Note that SISAL was a pure language that rivaled FOTRAN for
    performance.</li>
</ul>

